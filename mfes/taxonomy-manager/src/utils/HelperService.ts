import { useFrameworkFormStore } from '../store/frameworkFormStore';
import { useFrameworksStore } from '../store/frameworksStore';
import { post } from '../services/RestClient';
import { URL_CONFIG } from './url.config';

export interface SimulateApiResponse {
  url: string;
  method: string;
  data?: unknown;
  status: number;
}

export interface ApiErrorResponse {
  params?: { errmsg?: string };
  message?: string;
}

export interface AxiosErrorType {
  response?: {
    status?: number;
    data?: ApiErrorResponse;
  };
}

export async function simulateApiCall(
  url: string,
  method: string,
  data?: unknown
): Promise<SimulateApiResponse> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ url, method, data, status: 200 });
    }, 600);
  });
}

// Formats a date (string or Date object) into a readable string like "Jan 01, 2024".
export function formatDate(date: Date | string) {
  const d = new Date(date);
  const months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ];
  const month = months[d.getMonth()];
  const day = String(d.getDate()).padStart(2, '0');
  const year = d.getFullYear();
  return `${month} ${day}, ${year}`;
}

// Converts a string to camelCase, removing non-alphanumeric separators and capitalizing the following letter.
export function camelCaseCode(input: string): string {
  // Replace '&' with 'And'
  const replaced = input.replace(/&/g, 'And');
  // Remove all non-alphanumeric characters except spaces, dashes, and underscores for splitting
  const cleaned = replaced.replace(/[^a-zA-Z0-9\s-_]+/g, '');
  const trimmed = cleaned.trim().toLowerCase();

  return trimmed
    .split(/[-_\s]+/) // Split on any non-alphanumeric separator
    .map((word, index) => {
      if (index === 0) return word; // first word stays lowercase
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join('');
}

// Checks if a string is in camelCase format (starts with lowercase, only alphanumeric, no special characters)
export function isCamelCase(input: string): boolean {
  // CamelCase pattern: starts with lowercase letter, followed by only alphanumeric characters (no special chars)
  const camelCasePattern = /^[a-z][a-zA-Z0-9]*$/;
  return camelCasePattern.test(input);
}

// Returns a copy of the given object with the name updated and the code (or custom code field) auto-generated in camelCase from the name.
export function autoFillCodeFromName<T extends { name: string; code: string }>(
  obj: T,
  name: string,
  codeField?: string
): T {
  const codeKey = codeField || 'code';
  return {
    ...obj,
    name,
    [codeKey]: camelCaseCode(name),
  };
}

// Returns the name as the description (currently a pass-through, but can be extended).
export function autoGenerateDescriptionFromName(name: string): string {
  return name;
}

// Publishes a framework after any edit operation
export async function publishFramework(
  frameworkCode: string,
  channelId: string
): Promise<unknown> {
  // Add a 500ms delay before publishing
  await new Promise((res) => setTimeout(res, 500));

  const url = `${URL_CONFIG.API.FRAMEWORK_PUBLISH}/${frameworkCode}`;

  try {
    const response = await post(
      url,
      {},
      {
        'X-Channel-Id': channelId,
      }
    );

    return response.data;
  } catch (error: unknown) {
    // The interceptor already extracts meaningful error messages
    const errorMessage =
      error instanceof Error ? error.message : 'Failed to publish framework';
    console.error('Publish error:', errorMessage);
    throw new Error(errorMessage);
  }
}

// Publishes a framework after batch operations (categories, terms, associations)
// Handles channelId resolution from stores and error handling
export async function publishFrameworkAfterBatchOperation(
  frameworkCode: string,
  operationType: string,
  channelId?: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // Try to get channelId from argument first, then from stores
    let resolvedChannelId = channelId;
    if (!resolvedChannelId) {
      const framework = useFrameworkFormStore.getState().framework;
      const frameworks = useFrameworksStore.getState().frameworks;

      if (framework?.channel) {
        resolvedChannelId = framework.channel;
      } else {
        const currentFramework = frameworks.find(
          (fw) => fw.code === frameworkCode
        );
        resolvedChannelId = currentFramework?.channel;
      }
    }

    if (resolvedChannelId) {
      await publishFramework(frameworkCode, resolvedChannelId);
      return { success: true };
    } else {
      const errorMsg = `No channelId found for framework ${frameworkCode}`;
      console.warn(
        `Failed to publish framework after batch ${operationType}:`,
        errorMsg
      );
      return { success: false, error: errorMsg };
    }
  } catch (publishError) {
    const errorMsg =
      publishError instanceof Error ? publishError.message : 'Unknown error';
    console.warn(
      `Failed to publish framework after batch ${operationType}:`,
      publishError
    );
    return { success: false, error: errorMsg };
  }
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Testing Guide for Frontend Applications in NX Workspace with Jest</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        h4 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin-bottom: 8px;
        }
        .toc a {
            text-decoration: none;
            color: #3498db;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .benefits {
            background-color: #d4edda;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #28a745;
            margin: 15px 0;
        }
        .limitations {
            background-color: #f8d7da;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        .code-block {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .code-block code {
            background-color: transparent;
            color: #e2e8f0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <h1>Unit Testing Guide for Frontend Applications in NX Workspace with Jest</h1>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#overview">1. Overview</a></li>
            <li><a href="#prerequisites">2. Prerequisites</a></li>
            <li><a href="#nx-workspace-testing-setup">3. NX Workspace Testing Setup</a></li>
            <li><a href="#jest-configuration">4. Jest Configuration</a></li>
            <li><a href="#frontend-testing-types">5. Frontend Testing Types</a></li>
            <li><a href="#step-by-step-implementation">6. Step-by-Step Implementation</a></li>
            <li><a href="#testing-best-practices">7. Testing Best Practices</a></li>
            <li><a href="#benefits-of-unit-testing">8. Benefits of Unit Testing</a></li>
            <li><a href="#limitations-and-considerations">9. Limitations and Considerations</a></li>
            <li><a href="#troubleshooting">10. Troubleshooting</a></li>
            <li><a href="#conclusion">11. Conclusion</a></li>
        </ul>
    </div>

    <h2 id="overview">Overview</h2>
    <p>This document provides a comprehensive guide for implementing unit testing in NX workspace using Jest, specifically focused on frontend applications. NX provides excellent built-in support for Jest testing with optimized configurations and parallel execution capabilities.</p>

    <h2 id="prerequisites">Prerequisites</h2>
    <ul>
        <li>NX workspace (version 20.2.2 or higher)</li>
        <li>Node.js (version 18 or higher)</li>
        <li>TypeScript support</li>
        <li>React/Next.js applications</li>
        <li>Basic understanding of unit testing concepts</li>
    </ul>

    <h2 id="nx-workspace-testing-setup">NX Workspace Testing Setup</h2>

    <h3>1. NX Jest Plugin Configuration</h3>
    <p>NX automatically configures Jest through the <code>@nx/jest/plugin</code> in your <code>nx.json</code>:</p>

    <div class="code-block">
        <pre><code>{
  "plugins": [
    {
      "plugin": "@nx/jest/plugin",
      "options": {
        "targetName": "test"
      }
    }
  ]
}</code></pre>
    </div>

    <h3>2. Workspace-Level Jest Preset</h3>
    <p>The workspace uses a centralized Jest preset (<code>jest.preset.js</code>):</p>

    <div class="code-block">
        <pre><code>const nxPreset = require('@nx/jest/preset').default;
module.exports = { ...nxPreset };</code></pre>
    </div>

    <h3>3. Project-Level Jest Configuration</h3>
    <p>Each project has its own <code>jest.config.ts</code> that extends the workspace preset:</p>

    <div class="code-block">
        <pre><code>export default {
  displayName: 'project-name',
  preset: '../../jest.preset.js',
  transform: {
    '^(?!.*\\.(js|jsx|ts|tsx|css|json)$)': '@nx/react/plugins/jest',
    '^.+\\.[tj]sx?$': ['babel-jest', { presets: ['@nx/next/babel'] }],
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/project-name',
};</code></pre>
    </div>

    <h2 id="jest-configuration">Jest Configuration</h2>

    <h3>Key Configuration Options</h3>

    <div class="code-block">
        <pre><code>const config: Config = {
  // Clear mocks between tests
  clearMocks: true,

  // Enable coverage collection
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageProvider: 'v8',

  // Test environment for React components
  testEnvironment: 'jsdom',

  // Setup files for test environment
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],

  // Module name mapping for path aliases
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },

  // Transform configuration
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
};</code></pre>
    </div>

    <h3>Required Dependencies</h3>

    <div class="code-block">
        <pre><code>{
  "devDependencies": {
    "@nx/jest": "20.2.2",
    "@testing-library/jest-dom": "^6.4.6",
    "@testing-library/react": "15.0.6",
    "@testing-library/user-event": "^14.5.2",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.1.0",
    "@types/jest": "^29.5.12"
  }
}</code></pre>
    </div>

    <h2 id="frontend-testing-types">Frontend Testing Types</h2>

    <h3>1. Component Testing</h3>
    <ul>
        <li><strong>Purpose</strong>: Test React components in isolation</li>
        <li><strong>Tools</strong>: React Testing Library, Jest</li>
        <li><strong>What to test</strong>: Rendering, props, user interactions, state changes</li>
    </ul>

    <h3>2. Hook Testing</h3>
    <ul>
        <li><strong>Purpose</strong>: Test custom React hooks</li>
        <li><strong>Tools</strong>: @testing-library/react-hooks</li>
        <li><strong>What to test</strong>: Hook behavior, state updates, side effects</li>
    </ul>

    <h3>3. Utility Function Testing</h3>
    <ul>
        <li><strong>Purpose</strong>: Test pure functions and utilities</li>
        <li><strong>Tools</strong>: Jest</li>
        <li><strong>What to test</strong>: Input/output, edge cases, error handling</li>
    </ul>

    <h3>4. Service/API Testing</h3>
    <ul>
        <li><strong>Purpose</strong>: Test API calls and data fetching</li>
        <li><strong>Tools</strong>: Jest with mocking</li>
        <li><strong>What to test</strong>: API calls, error handling, data transformation</li>
    </ul>

    <h3>5. Integration Testing</h3>
    <ul>
        <li><strong>Purpose</strong>: Test component interactions</li>
        <li><strong>Tools</strong>: React Testing Library</li>
        <li><strong>What to test</strong>: Component communication, user workflows</li>
    </ul>

    <h2 id="step-by-step-implementation">Step-by-Step Implementation</h2>

    <h3>Step 1: Create Test Setup File</h3>
    <p>Create <code>jest.setup.ts</code> in your project root:</p>

    <div class="code-block">
        <pre><code>import '@testing-library/jest-dom';

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
};</code></pre>
    </div>

    <h3>Step 2: Create Test Utilities</h3>
    <p>Create <code>src/test-utils.tsx</code>:</p>

    <div class="code-block">
        <pre><code>import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Mock providers for testing
const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
};

const customRender = (ui: ReactElement, options?: Omit<RenderOptions, 'wrapper'>) => render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };</code></pre>
    </div>

    <h3>Step 3: Write Component Tests</h3>
    <p>Example component test (<code>Button.test.tsx</code>):</p>

    <div class="code-block">
        <pre><code>import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('applies disabled state correctly', () => {
    render(<Button disabled>Disabled button</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});</code></pre>
    </div>

    <h3>Step 4: Write Hook Tests</h3>
    <p>Example hook test (<code>useCounter.test.ts</code>):</p>

    <div class="code-block">
        <pre><code>import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('should initialize with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it('should increment count', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });
});</code></pre>
    </div>

    <h3>Step 5: Write API Service Tests</h3>
    <p>Example API test (<code>api.test.ts</code>):</p>

    <div class="code-block">
        <pre><code>import { fetchUserData } from './api';
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(ctx.json({ id: '1', name: 'John Doe' }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('API Service', () => {
  it('fetches user data successfully', async () => {
    const userData = await fetchUserData('1');
    expect(userData).toEqual({ id: '1', name: 'John Doe' });
  });
});</code></pre>
    </div>

    <h3>Step 6: Run Tests</h3>

    <div class="code-block">
        <pre><code># Run all tests
nx test

# Run tests for specific project
nx test project-name

# Run tests in watch mode
nx test project-name --watch

# Run tests with coverage
nx test project-name --coverage

# Run tests in CI mode
nx test project-name --ci</code></pre>
    </div>

    <h2 id="testing-best-practices">Testing Best Practices</h2>

    <h3>1. Test Structure (AAA Pattern)</h3>

    <div class="code-block">
        <pre><code>describe('ComponentName', () => {
  it('should do something specific', () => {
    // Arrange - Set up test data and mocks
    const mockProps = { title: 'Test Title' };

    // Act - Execute the function or render component
    render(<Component {...mockProps} />);

    // Assert - Verify the expected outcome
    expect(screen.getByText('Test Title')).toBeInTheDocument();
  });
});</code></pre>
    </div>

    <h3>2. Meaningful Test Names</h3>

    <div class="code-block">
        <pre><code>// Good
it('should display error message when API call fails');

// Bad
it('should work');</code></pre>
    </div>

    <h3>3. Test User Behavior, Not Implementation</h3>

    <div class="code-block">
        <pre><code>// Good - Test what user sees
expect(screen.getByRole('button')).toBeInTheDocument();

// Bad - Test implementation details
expect(component.state.isVisible).toBe(true);</code></pre>
    </div>

    <h3>4. Use Data Test IDs Sparingly</h3>

    <div class="code-block">
        <pre><code>// Only when semantic queries don't work
&lt;button data-testid="submit-button"&gt;Submit&lt;/button&gt;</code></pre>
    </div>

    <h3>5. Mock External Dependencies</h3>

    <div class="code-block">
        <pre><code>// Mock API calls
jest.mock('./api', () => ({
  fetchData: jest.fn(),
}));

// Mock modules
jest.mock('next/router', () => ({
  useRouter: () => ({
    push: jest.fn(),
    pathname: '/test',
  }),
}));</code></pre>
    </div>

    <h2 id="benefits-of-unit-testing">Benefits of Unit Testing</h2>

    <div class="benefits">
        <h3>1. Early Bug Detection</h3>
        <ul>
            <li>Catch bugs during development phase</li>
            <li>Reduce production issues</li>
            <li>Faster debugging process</li>
        </ul>

        <h3>2. Code Quality Improvement</h3>
        <ul>
            <li>Forces better code structure</li>
            <li>Encourages modular design</li>
            <li>Improves maintainability</li>
        </ul>

        <h3>3. Documentation</h3>
        <ul>
            <li>Tests serve as living documentation</li>
            <li>Show expected behavior</li>
            <li>Help new developers understand code</li>
        </ul>

        <h3>4. Refactoring Confidence</h3>
        <ul>
            <li>Safe to refactor with test coverage</li>
            <li>Regression prevention</li>
            <li>Maintain functionality during changes</li>
        </ul>

        <h3>5. Development Speed</h3>
        <ul>
            <li>Faster debugging</li>
            <li>Automated testing</li>
            <li>Continuous integration support</li>
        </ul>

        <h3>6. Team Collaboration</h3>
        <ul>
            <li>Shared understanding of requirements</li>
            <li>Reduced code review time</li>
            <li>Better code quality standards</li>
        </ul>
    </div>

    <h2 id="limitations-and-considerations">Limitations and Considerations</h2>

    <div class="limitations">
        <h3>1. Testing Limitations</h3>
        <ul>
            <li><strong>Cannot test visual appearance</strong>: Jest can't verify CSS styling or visual design</li>
            <li><strong>Limited browser testing</strong>: No real browser environment</li>
            <li><strong>Mock limitations</strong>: Mocks may not perfectly replicate real behavior</li>
            <li><strong>Integration gaps</strong>: Unit tests don't catch integration issues</li>
        </ul>

        <h3>2. Performance Considerations</h3>
        <ul>
            <li><strong>Test execution time</strong>: Large test suites can be slow</li>
            <li><strong>Memory usage</strong>: Each test runs in isolation</li>
            <li><strong>CI/CD impact</strong>: Tests must complete before deployment</li>
        </ul>

        <h3>3. Development Time Impact</h3>
        <ul>
            <li><strong>Initial setup time</strong>: 15-25% increase in initial development time for test setup and configuration</li>
            <li><strong>Ongoing development</strong>: 20-40% increase in feature development time due to writing tests</li>
            <li><strong>Learning curve</strong>: 2-4 weeks additional time for team members to learn testing best practices</li>
            <li><strong>Test maintenance</strong>: 10-15% additional time for maintaining and updating existing tests</li>
            <li><strong>Debugging tests</strong>: 5-10% additional time spent debugging test failures and flaky tests</li>
        </ul>

        <h3>4. Maintenance Overhead</h3>
        <ul>
            <li><strong>Test maintenance</strong>: Tests need updates when code changes</li>
            <li><strong>False positives</strong>: Tests may fail due to implementation changes</li>
            <li><strong>Test complexity</strong>: Complex tests can be hard to maintain</li>
        </ul>

        <h3>5. Coverage Limitations</h3>
        <ul>
            <li><strong>100% coverage doesn't mean bug-free</strong>: Edge cases may be missed</li>
            <li><strong>Integration testing needed</strong>: Unit tests don't cover system interactions</li>
            <li><strong>User experience testing</strong>: Cannot test actual user workflows</li>
        </ul>

        <h3>6. Frontend-Specific Challenges</h3>
        <ul>
            <li><strong>DOM manipulation</strong>: Complex DOM interactions are hard to test</li>
            <li><strong>Async operations</strong>: Testing async code requires careful handling</li>
            <li><strong>State management</strong>: Complex state interactions can be difficult to test</li>
            <li><strong>Third-party libraries</strong>: Some libraries are hard to mock effectively</li>
        </ul>
    </div>

    <h2 id="troubleshooting">Troubleshooting</h2>

    <h3>Common Issues and Solutions</h3>

    <h4>1. Module Resolution Issues</h4>

    <div class="code-block">
        <pre><code>// Add to jest.config.ts
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/src/$1',
  '^@shared/(.*)$': '<rootDir>/../../libs/shared-lib/src/$1',
}</code></pre>
    </div>

    <h4>2. CSS Import Issues</h4>

    <div class="code-block">
        <pre><code>// Add to jest.config.ts
moduleNameMapper: {
  '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
}</code></pre>
    </div>

    <h4>3. Environment Variables</h4>

    <div class="code-block">
        <pre><code>// Add to jest.setup.ts
process.env.NODE_ENV = 'test';
process.env.API_URL = 'http://localhost:3000';</code></pre>
    </div>

    <h4>4. Async Testing</h4>

    <div class="code-block">
        <pre><code>// Use async/await
it('should handle async operations', async () => {
  const { result } = renderHook(() => useAsyncData());

  await waitFor(() => {
    expect(result.current.data).toBeDefined();
  });
});</code></pre>
    </div>

    <h4>5. Memory Leaks</h4>

    <div class="code-block">
        <pre><code>// Clean up after tests
afterEach(() => {
  cleanup();
  jest.clearAllMocks();
});</code></pre>
    </div>

    <h2 id="conclusion">Conclusion</h2>

    <p>Unit testing in NX workspace with Jest provides a robust foundation for frontend application testing. While it has limitations, the benefits significantly outweigh the challenges when implemented correctly. Focus on testing user behavior, maintain good test coverage, and complement unit tests with integration and end-to-end tests for comprehensive quality assurance.</p>

    <div class="highlight">
        <h3>Key Takeaways:</h3>
        <ul>
            <li>Use NX's built-in Jest configuration for optimal performance</li>
            <li>Focus on testing user behavior rather than implementation details</li>
            <li>Maintain good test coverage but don't obsess over 100%</li>
            <li>Complement unit tests with other testing strategies</li>
            <li>Keep tests simple, readable, and maintainable</li>
            <li>Use proper mocking and test utilities for complex scenarios</li>
        </ul>
    </div>

    <p>This testing strategy will help ensure your frontend applications are reliable, maintainable, and bug-free while supporting your team's development workflow.</p>

    <div class="footer">
        <p><strong>Document Generated:</strong> Unit Testing Guide for Frontend Applications in NX Workspace with Jest</p>
        <p><strong>Version:</strong> 1.0 | <strong>Date:</strong> 2024</p>
    </div>
</body>
</html>
